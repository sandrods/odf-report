<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>ODF-Report by sandrods</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>ODF-Report</h1>
        <p>Gem for generating .odt files by making string, image, table and section replacements in a previously created .odt file.</p>
        <p class="view"><a href="https://github.com/sandrods/odf-report">View the Project on GitHub <small>sandrods/odf-report</small></a></p>
        <ul>
          <li><a href="https://github.com/sandrods/odf-report/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/sandrods/odf-report/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/sandrods/odf-report">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>

<h2>INSTALL</h2>

<p>In your Gemfile</p>

<pre><code>gem 'odf-report'</code></pre>

<h2>USAGE</h2>

<h3>Step 1 &mdash; the template</h3>

<p>First of all, you need a <code>.odt</code> file to serve as a template.
Templates are normal .odt files with <code>[PLACEHOLDERS]</code> for <em>substitutions</em>.
There are <em>five</em> kinds of substitutions available:</p>

<ul>
  <li>fields</li>
  <li>texts</li>
  <li>tables</li>
  <li>images</li>
  <li>sections</li>
</ul>

<h4>Fields</h4>

<p>It's just an uppercase sentence, surrounded by brackets. It will be replaced by the value you supply.</p>

<p>In the following example:</p>

<pre><code>report = ODFReport::Report.new("Users/john/my_template.odt") do |r|
  r.add_field :user_name, @user.name
  r.add_field :address, "My new address"
end</code></pre>

<p>All occurrences of <code>[USER_NAME]</code> found in the file will be replaced by the value of <code>@user.name</code> whereas all <code>[ADDRESS]</code> 'es will contain <code>My new address</code></p>

<h4>Texts (HTML formatted content)</h4>

<p>You can use <code>add_text</code> to replace a placeholder with rich HTML content, which gets converted into ODF-formatted paragraphs with support for inline formatting (<code>&lt;strong&gt;</code>, <code>&lt;em&gt;</code>, <code>&lt;u&gt;</code>), headings, blockquotes, and line breaks.</p>

<pre><code>report = ODFReport::Report.new("my_template.odt") do |r|
  r.add_text :description, '&lt;p&gt;A paragraph with &lt;strong&gt;bold&lt;/strong&gt; and &lt;em&gt;italic&lt;/em&gt; text.&lt;/p&gt;'
end</code></pre>

<p>For full details on supported tags, required template styles, and examples, see the <a href="https://github.com/sandrods/odf-report/wiki/Using-add_text-with-HTML-formatting">Using add_text with HTML formatting</a> wiki page.</p>

<h4>Tables</h4>

<p>To use table placeholders, you should create a Table in your document and give it a name. In OpenOffice, it's just a matter of right-clicking the table you just created, choose <em>Table Properties...</em> and type a name in the Name field.</p>

<p>If you inform <code>header: true</code>, the first row will be treated as a <em>header</em> and left untouched. The remaining rows will be used as the template for the table.</p>

<p>If you have more than one template row, they will be cycled. This is useful for making zebra tables.</p>

<p>As with <strong>Field placeholders</strong>, just insert a <code>[FIELD_NAME]</code> in each cell and let the magic take place.</p>

<p>Taking the following example:</p>

<pre><code>report = ODFReport::Report.new("Users/john/my_template.odt") do |r|

  r.add_field "USER_NAME", @user.nome
  r.add_field "ADDRESS", @user.address

  r.add_table("TABLE_1", @list_of_items, header: true) do |t|
    t.add_column(:item_id, :id)
    t.add_column(:description) { |item| "==> #{item.description}" }
  end

end</code></pre>

<p>and considering you have a table like this in your template</p>

<table>
  <tr><th>#ID</th><th>Description</th></tr>
  <tr><td>[ITEM_ID]</td><td>[DESCRIPTION]</td></tr>
</table>

<p>and a collection <code>@list_of_items</code>, it will create one row for each item in the collection, and the replacement will take place accordingly.</p>

<p>Any format applied to the fields in the template will be preserved.</p>

<h4>Sections</h4>

<p>Sometimes, you have to repeat a whole chunk of a document, in a structure a lot more complex than a table. You can make a Section in your template and use it in these situations. Creating a Section in OpenOffice is as easy as selecting menu <em>Insert</em> and then <em>Section...</em>, and then choose a name for it.</p>

<p>Sections are a lot like Tables, in the sense that you can pass a collection and have that section repeated for each member of the collection. <em>But</em>, Sections can have anything inside them, even Tables <em>and nested Sections</em>, as long as you provide the appropriate data structure.</p>

<p>Let's see an example:</p>

<pre><code>  @invoices = Invoice.find(:all)

  report = ODFReport::Report.new("reports/invoice.odt") do |r|

    r.add_field(:title, "INVOICES REPORT")
    r.add_field(:date, Date.today)

    r.add_section("SC_INVOICE", @invoices) do |s|

      s.add_field(:number) { |invoice| invoice.number.to_s.rjust(5, '0') }
      s.add_field(:name,    :customer_name)
      s.add_field(:address, :customer_address)

      s.add_table("TB_ITEMS", :items, header: true) do |t|
        t.add_column(:id)
        t.add_column(:product) {|item| item.product.name }
        t.add_column(:value, :product_value)
      end

      s.add_field(:total) do |invoice|
        if invoice.status == 'CLOSED'
          invoice.total
        else
          invoice.items.sum('product_value')
        end
      end

      s.add_section("SUB_NOTES", :notes) do |s1|

        s1.add_field(:note_title) { |n| n.title }

        s1.add_table ...

      end

    end

  end</code></pre>

<p>Note that when you add a Table to a Section, you don't pass the collection itself, but the attribute of the item of that section that will return the collection for that particular Table. Sounds complicated, huh? But once you get it, it's quite straightforward.</p>

<p>In the above example, <code>s.add_table("TB_ITEMS", :items, header: true) do |t|</code>, the <code>:items</code> thing refers to a <code>invoice.items</code>. Easy, right?</p>

<h4>Images</h4>

<p>You must put a mock image in your <code>.odt</code> template and give it a name. That name will be used to replace the mock image for the actual image.
You can also assign any properties you want to the mock image and they will be kept once the image is replaced.</p>

<p>An image replace would look like this:</p>

<pre><code>report = ODFReport::Report.new("my_template.odt") do |r|
  r.add_image :graphic1, "/path/to/the/image.jpg"

  r.add_table("TABLE_WITH_IMAGES", @items) do |t|
    t.add_column(:id)
    t.add_column(:product, :product_name)
    t.add_image('PRODUCT_IMAGE') { |item| item.image_path }
  end
end</code></pre>

<hr>

<h3>Step 2 &mdash; generating the document</h3>

<p>It's fairly simple to generate the document. You can use this inside a Rails application or in a standalone script.</p>

<h4>Generating a document in a Rails application</h4>

<p>In a controller, you can have a code like this:</p>

<pre><code>def print

  @ticket = Ticket.find(params[:id])

  report = ODFReport::Report.new(Rails.root.join("/app/reports/ticket.odt")) do |r|

    r.add_field(:id,         @ticket.id.to_s)
    r.add_field(:created_by, @ticket.created_by)
    r.add_field(:created_at, @ticket.created_at.strftime("%d/%m/%Y - %H:%M"))
    r.add_field(:type,       @ticket.type.name)
    r.add_field(:status,     @ticket.status_text)
    r.add_field(:date,       Time.now.strftime("%d/%m/%Y - %H:%M"))
    r.add_field(:solution,   (@ticket.solution || ''))

    r.add_table("OPERATORS", @ticket.operators) do |t|
      t.add_column(:name) { |op| "#{op.name} (#{op.department.short_name})" }
    end

    r.add_table("FIELDS", @ticket.fields) do |t|
      t.add_column(:field_name, :name)
      t.add_column(:field_value) { |field| field.text_value || "Empty" }
    end

  end

  send_data report.generate,
            type: 'application/vnd.oasis.opendocument.text',
            disposition: 'attachment',
            filename: 'report.odt'

end</code></pre>

<h4>Generating a document in a standalone script</h4>

<p>It's very similar to a Rails app, but you can inform the path where the file will be saved.</p>

<pre><code>report = ODFReport::Report.new("ticket.odt") do |r|
... populates the report ...
end

report.generate("./documents/new_ticket.odt")</code></pre>

<h4>Using a template stored in the database (or anywhere besides the file system)</h4>

<p>You can provide an <code>io:</code> param, containing the actual file read into a String.</p>

<pre><code>report = ODFReport::Report.new(io: @template.attachment.read) do |r|</code></pre>

<hr>

<h4>REQUIREMENTS</h4>

<ul>
  <li><strong>rubyzip</strong>: manipulating the contents of the odt file, since it's actually a zip file.</li>
  <li><strong>nokogiri</strong>: parsing and manipulating the document xml files.</li>
  <li><strong>mime-types</strong>: identify image MIME types.</li>
</ul>

<h4>TROUBLESHOOTING</h4>

<h5>Placeholder not replaced</h5>

<p>If your placeholder is not being replaced, the problem might come from OpenOffice/LibreOffice which, when a placeholder is edited, adds some markup that prevents odf-report from identifying the placeholder.</p>

<p>The golden rule is: NEVER edit the placeholders. If you want to change one, delete it and write again, including the <code>[]</code>.
Example: if you have, say, <code>[USER]</code> in your template and you want to change to <code>[USERNAME]</code>, you should not edit and type NAME.
Delete the PLACEHOLDER <code>[USER]</code> and type <code>[USERNAME]</code>.</p>

<h5>Word found unreadable content</h5>

<ul>
  <li>Symptom: You prepare your template file in eg. LibreOffice, and when you open the template in Word it says "Word found unreadable content"</li>
  <li>Solution: Open your template in LibreOffice, save as <code>.docx</code>, quit LibreOffice. Open the <code>.docx</code> in LibreOffice, save as <code>.odt</code>.</li>
  <li>Hypothesis: Word does not support all ODT features. Saving as <code>.docx</code> removes those features of the document.</li>
</ul>

      </section>
    </div>
    <footer>
      <p>Project maintained by <a href="https://github.com/sandrods">sandrods</a></p>
      <p>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></p>
    </footer>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
  </body>
</html>
